# 1019
youtube를 클론하는 프로젝트를 하고 있습니다. 참고로 영상은 file입니다. 다음 프로젝트를 완성하세요.

1. 작동되는 models.py를 각 반에 업로드 하세요.
2. 작동되는 views.py를 각 반에 업로드 하세요.

/tube   
/tube/1                     # 영상 재생이 되어야 합니다. 뎃글을 달 수 있어야 합니다.
/tube/create/               # 로그인한 사용자만 보기 가능
/tube/update/<int:pk>/      # 로그인한 사용자만 보기 가능
/tube/delete/<int:pk>/      # 로그인한 사용자만 보기 가능
/tube/tag/<str:tag>/        # 해당 태그가 달린 목록을 가져와야 합니다.
/tube/?q='keyword'          # 해당 키워드가 포함된 title, content가 있는 목록을 가져와야 합니다.
/accounts/signup/
/accounts/login/
/accounts/logout/           # 로그인한 사용자만 보기 가능
/accounts/profile/          # 로그인한 사용자만 보기 가능


mkdir 1019
cd 1019

pip freeze > requirements.txt
# pip install -r requirements.txt # 추후 이 파일을 통해 설치합니다.

django-admin startproject tutorialdjango .
python manage.py migrate

# settings.py에서 접속할 수 있는 사람 설정
ALLOWED_HOSTS = ['*'] # 28번째 줄에 접속할 수 있는 사람을 모든 사람으로 변경

python manage.py startapp tube
python manage.py startapp accounts

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    #custom apps
    'accounts',
    'tube',
]
'DIRS': [BASE_DIR / 'templates'],


# 언어와 시간 설정
LANGUAGE_CODE = 'ko-kr'

TIME_ZONE = 'Asia/Seoul'


STATIC_URL = 'static/'
STATICFILES_DIRS = [
    BASE_DIR / 'static',
]

MEDIA_ROOT = BASE_DIR / 'media'
MEDIA_URL = '/media/'


###################################

static, media, templates > tube, templates > accounts 폴더 생성

###################################

python manage.py createsuperuser

########################################
# tutorialdjango > urls.py

from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings
from django.views.generic.base import RedirectView

urlpatterns = [
    # path('', RedirectView.as_view(url='tube/'), name='root'),
    path('', RedirectView.as_view(pattern_name='tube:post_list'), name='root'),
    path('admin/', admin.site.urls),
    path('tube/', include('tube.urls')),
    path('accounts/', include('accounts.urls')),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

##########################################
tube > urls.py



##########################################
accounts > urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('signup/', views.signup, name='signup'),
    path('login/', views.login, name='login'),
    path('logout/', views.logout, name='logout'),
    path('profile/', views.profile, name='profile')
]



############################################
accounts > views.py

from django.conf import settings
from django.contrib.auth.decorators import login_required
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.views import LoginView, LogoutView
from django.shortcuts import render
from django.views.generic import CreateView


signup = CreateView.as_view(
    form_class = UserCreationForm,
    template_name = 'accounts/form.html',
    success_url = '/accounts/login/'
)

login = LoginView.as_view(
    template_name = 'accounts/form.html',
)

logout = LogoutView.as_view(
    next_page = '/accounts/login/'
)

@login_required
def profile(request):
    return render(request, 'accounts/profile.html')


####################
templates > accounts > form.html

<form action="" method = 'post'>
  {% csrf_token %}
  <table>
    {{ form.as_table }}
  </table>
  <input type="submit" value="Submit">
</form>

#####################

templates > accounts > profile.html

<!DOCTYPE html>
<html lang="ko-KR">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>프로필</title>
</head>

<body>
  <h1>프로필 페이지입니다.</h1>
  <p>{{user}}의 프로필</p>
      
</body>

</html>


#######################
tube > models.py                              

from django.db import models
from django.contrib.auth.models import User

class Post(models.Model):
    author = models.ForeignKey(
        User, on_delete=models.CASCADE
    )
    title = models.CharField(max_length=100)
    content = models.TextField()
    thumb_image = models.ImageField(
        upload_to='tube/images/%Y/%m/%d/', blank=True)
    file_upload = models.FileField(
        upload_to='tube/files/%Y/%m/%d/', blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    view_count = models.PositiveIntegerField(default=0)
    tags = models.ManyToManyField('Tag', blank=True)

    def __str__(self):
        return self.title
    
    def get_absolute_url(self):
        return f'/tube/{self.pk}/'    
    
class Comment(models.Model):
    post = models.ForeignKey(
        Post, on_delete=models.CASCADE, related_name='comments'
    )
    author = models.ForeignKey(
        User, on_delete=models.CASCADE
    )
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)
    
    def __str__(self):
        return self.message
    
class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)
    def __str__(self):
        return self.name

###########################
tube > admin.py

from django.contrib import admin
from .models import Post, Comment, Tag

admin.site.register(Post)
admin.site.register(Comment)
admin.site.register(Tag)


############################
자료:https://paullabworkspace.notion.site/sample-assets-b7de17d3108145659216619aa82dc327

게시글 3개 작성하기

############################
tube > forms.py

from django import forms
from .models import Post, Comment, Tag

class PostForm(forms.ModelForm):
  class Meta:
    model = Post
    fields = ['title', 'content', 'thumb_imgae', 'file_upload']


class CommentForm(forms.ModelForm):
  class Meta:
    model = Comment
    fields = ['message']

class TagForm(forms.ModelForm):
  class Meta:
    model = Tag
    fields = ['name']

#########################
tube > urls.py
from django.urls import path
from . import views

app_name = 'tube'

urlpatterns = [
    path('', views.post_list, name='post_list'),
    path('new/', views.post_new, name='post_new'),
    path('<int:pk>/', views.post_detail, name='post_detail'),
    path('<int:pk>/edit/', views.post_edit, name='post_edit'),
    path('<int:pk>/delete/', views.post_delete, name='post_delete'),
]

###############################
tube > views.py
# write는 로그인 해야만
# update와 delete는 업로드한 사용자여야만

from typing import Any
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.shortcuts import render
from django.views.generic import ListView, DeleteView, UpdateView, DetailView, CreateView
from .models import Post, Comment
from .forms import PostForm, CommentForm
from django.urls import reverse_lazy
from django.shortcuts import redirect
from django.contrib.auth.decorators import login_required

class PostListView(ListView):
    model = Post

post_list = PostListView.as_view()


class PostCreateView(LoginRequiredMixin, CreateView):
    model = Post
    form_class = PostForm
    success_url = reverse_lazy('tube:post_list')
    template_name = 'tube/form.html'

    def form_valid(self, form):
        video = form.save(commit=False) # commit=False는 DB에 저장하지 않고 객체만 반환
        video.author = self.request.user
        return super().form_valid(form) # 이렇게 호출했을 때 저장합니다.

post_new = PostCreateView.as_view()


class PostDetailView(DetailView):
    model = Post
    # context_object_name = 'licat_objects' # {{licat_objects.title}} 이런식으로 사용 가능
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['comment_form'] = CommentForm()
        return context

post_detail = PostDetailView.as_view()


class PostUpdateView(UserPassesTestMixin, UpdateView):
    model = Post
    form_class = PostForm
    success_url = reverse_lazy('tube:post_list')
    template_name = 'tube/form.html'

    def test_func(self): # UserPassesTestMixin에 있고 test_func() 메서드를 오버라이딩, True, False 값으로 접근 제한
        return self.get_object().author == self.request.user


post_edit = PostUpdateView.as_view()


class PostDeleteView(UserPassesTestMixin, DeleteView):
    model = Post
    success_url = reverse_lazy('tube:post_list')

    def test_func(self): # UserPassesTestMixin에 있고 test_func() 메서드를 오버라이딩, True, False 값으로 접근 제한
        return self.get_object().author == self.request.user

post_delete = PostDeleteView.as_view()

@login_required
def comment_new(request, pk):
    post = Post.objects.get(pk=pk)
    if request.method == 'POST':
        form = CommentForm(request.POST)
        if form.is_valid():
            comment = form.save(commit=False) # commit=False는 DB에 저장하지 않고 객체만 반환
            comment.post = post
            comment.author = request.user
            comment.save()
            return redirect('tube:post_detail', pk)
    else:
        form = CommentForm()
    return render(request, 'tube/form.html', {
        'form': form,
    })

##################################

tube > form.html

<form action="" method="post" enctype="multipart/form-data">
    {% csrf_token %}
    <table>
        {{ form.as_table }}
    </table>
    <input type="submit" value="Submit">
</form>

###################################
tube > post_confirm_delete.html
<h1>글 삭제</h1>

<form method="post">
    {% csrf_token %}
    <p>글을 삭제하시겠습니까?</p>
    <input type="submit" value="네!" class="btn btn-primary">
</form>

###################################

tube > post_detail.html
# object.title, post.title 둘다 접근 가능
<p>{{object.title}}</p>
<p>{{object.content}}</p>

<p>{{post.title}}</p>
<p>{{post.content}}</p>
{% if post.file_upload %}
<video src="{{post.file_upload.url}}" controls></video>
{% endif %}

<hr>
<section>
    <h3>댓글</h3>
    {% for comment in post.comments.all %}
        <p>{{comment.message}}</p>
        <p>{{comment.author}}</p>
        <p>{{comment.updated_at}}</p>
    {% endfor %}
</section>

<section>
    <h3>댓글 작성</h3>
    <form action="{% url 'tube:comment_create' post.pk %}" method="post">
        {% csrf_token %}
        {{ comment_form.as_p }}
        <input type="submit" value="댓글 작성">
    </form>
</section>

<a href="{% url 'tube:post_list' %}">목록</a>
{% if user == post.author %}
<a href="{% url 'tube:post_edit' post.pk %}">수정</a>
<a href="{% url 'tube:post_delete' post.pk %}">삭제</a>
{% endif %}


####################################
tube > post_list.html
<ul>
    {% for post in post_list %}
    <li>
        <a href="{% url 'tube:post_detail' post.pk %}">
            {{ post.title }}
        </a>
    </li>
    {% endfor %}
</ul>
<a href="{% url 'tube:post_new' %}">업로드</a>


###########################################

# 댓글작성

10.11 blog 코드
def blog(request):
    # db = Blog.objects.all()
    context = {
        'db': db,
    }
    return render(request, 'blog/blog.html', context)



전달되는 context 조정

views.py > PostDetailView

class PostDetailView(DetailView):
    model = Post
    # context_object_name = 'licat_objects' # {{licat_objects.title}} 이런식으로 사용 가능
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['comment_form'] = CommentForm()
        return context

post_detail = PostDetailView.as_view()


urls.py
path('<int:pk>/comment/new', views.comment_new, name='comment_new'),

##############################################

post_detail.html

<p>{{object.title}}</p>
<p>{{object.content}}</p>

<p>{{post.title}}</p>
<p>{{post.content}}</p>
<p>조회수 : {{post.view_count}}</p>
{% if post.file_upload %}
<video src="{{post.file_upload.url}}" controls></video>
{% endif %}

<hr>
<section>
    <h3>댓글</h3>
    {% for comment in post.comments.all %}
        <p>{{comment.message}}</p>
        <p>{{comment.author}}</p>
        <p>{{comment.updated_at}}</p>
    {% endfor %}
</section>

<section>
    <h3>댓글 작성</h3>
    <form action="{% url 'tube:comment_new' post.pk %}" method="post">
        {% csrf_token %}
        {{ comment_form.as_p }}
        <input type="submit" value="댓글 작성">
    </form>
</section>

<a href="{% url 'tube:post_list' %}">목록</a>
{% if user == post.author %}
<a href="{% url 'tube:post_edit' post.pk %}">수정</a>
<a href="{% url 'tube:post_delete' post.pk %}">삭제</a>
{% endif %}



#####################################
# 조회수
tube > views.py

class PostDetailView(DetailView):
    model = Post
    # context_object_name = 'licat_objects' # {{licat_objects.title}} 이런식으로 사용 가능

    def get_context_data(self, **kwargs):
        '''
        여기서 원하는 쿼리셋이나 object를 추가한 후 템플릿으로 전달할 수 있습니다.
        '''
        context = super().get_context_data(**kwargs)
        context['comment_form'] = CommentForm()
        return context
    
    def get_object(self, queryset=None):
        pk = self.kwargs.get('pk')
        post = Post.objects.get(pk=pk)
        post.view_count += 1
        post.save()
        return super().get_object(queryset)

post_detail = PostDetailView.as_view()

# 검색

# write는 로그인 해야만
# update와 delete는 업로드한 사용자여야만

from typing import Any
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.shortcuts import render
from django.views.generic import ListView, DeleteView, UpdateView, DetailView, CreateView
from .models import Post, Comment
from .forms import PostForm, CommentForm
from django.urls import reverse_lazy
from django.shortcuts import redirect
from django.contrib.auth.decorators import login_required

class PostListView(ListView):
    model = Post
    def get_queryset(self):
      qs = super().get_queryset()
      q = self.request.GET.get('q', '')
      if q:
          qs = qs.filter(title__icontains=q)
      return qs

post_list = PostListView.as_view()


class PostCreateView(LoginRequiredMixin, CreateView):
    model = Post
    form_class = PostForm
    success_url = reverse_lazy('tube:post_list')
    template_name = 'tube/form.html'

    def form_valid(self, form):
        video = form.save(commit=False) # commit=False는 DB에 저장하지 않고 객체만 반환
        video.author = self.request.user
        return super().form_valid(form) # 이렇게 호출했을 때 저장합니다.

post_new = PostCreateView.as_view()


class PostDetailView(DetailView):
    model = Post
    # context_object_name = 'licat_objects' # {{licat_objects.title}} 이런식으로 사용 가능

    def get_context_data(self, **kwargs):
        '''
        여기서 원하는 쿼리셋이나 object를 추가한 후 템플릿으로 전달할 수 있습니다.
        '''
        context = super().get_context_data(**kwargs)
        context['comment_form'] = CommentForm()
        return context
    
    def get_object(self, queryset=None):
        pk = self.kwargs.get('pk')
        post = Post.objects.get(pk=pk)
        post.view_count += 1
        post.save()
        return super().get_object(queryset)

post_detail = PostDetailView.as_view()


class PostUpdateView(UserPassesTestMixin, UpdateView):
    model = Post
    form_class = PostForm
    success_url = reverse_lazy('tube:post_list')
    template_name = 'tube/form.html'

    def test_func(self): # UserPassesTestMixin에 있고 test_func() 메서드를 오버라이딩, True, False 값으로 접근 제한
        return self.get_object().author == self.request.user


post_edit = PostUpdateView.as_view()


class PostDeleteView(UserPassesTestMixin, DeleteView):
    model = Post
    success_url = reverse_lazy('tube:post_list')

    def test_func(self): # UserPassesTestMixin에 있고 test_func() 메서드를 오버라이딩, True, False 값으로 접근 제한
        return self.get_object().author == self.request.user

post_delete = PostDeleteView.as_view()

@login_required
def comment_new(request, pk):
    post = Post.objects.get(pk=pk)
    if request.method == 'POST':
        form = CommentForm(request.POST)
        if form.is_valid():
            comment = form.save(commit=False) # commit=False는 DB에 저장하지 않고 객체만 반환
            comment.post = post
            comment.author = request.user
            comment.save()
            return redirect('tube:post_detail', pk)
    else:
        form = CommentForm()
    return render(request, 'tube/form.html', {
        'form': form,
    })

    
















###################################
# blog > models.py

from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    head_image = models.ImageField(
        upload_to='blog/images/%Y/%m/%d/', blank=True)
    file_upload = models.FileField(
        upload_to='blog/files/%Y/%m/%d/', blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateField(auto_now=True)

    def __str__(self):
        return self.title

###################################

python manage.py makemigrations
python manage.py migrate

###################################

python manage.py createsuperuser

leehojun
leehojun@gmail.com
이호준123!@

###################################

이미지가 실제 저장될 폴더 설정입니다.
settings.py에 맨 마지막 줄에 추가해주세요.

MEDIA_ROOT = BASE_DIR / 'media'
MEDIA_URL = '/media/'

###################################
# 언어와 시간 설정
LANGUAGE_CODE = 'ko-kr'

TIME_ZONE = 'Asia/Seoul'

###################################
# 템플릿 설정
TEMPLATES = [
    {
        ... 생략 ...
        'DIRS': [BASE_DIR / 'templates'],

###################################
# tutorialdjango > urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls')),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

###################################
# blog > urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.postlist, name='postlist'),
]

###################################
# blog > views.py

from django.shortcuts import render
from .models import Post

def postlist(request):
    posts = Post.objects.all()
    return render(request, 'blog/postlist.html', {'posts':posts})

###################################
mysite > templates > blog > postlist.html

{% for post in posts %}
    <p>{{post.title}}</p>
    <p>{{post.content}}</p>
    <hr>
{% endfor %}

###################################
blog > admin.py

from django.contrib import admin
from .models import Post

admin.site.register(Post)

###################################

python manage.py runserver

admin page 들어가셔서 게시물 3개 생성

1 11
2 22
3 33

###################################
# templates > admin > base_site.html
# https://github.com/django/django
# https://github.com/django/django/tree/main/django/contrib/admin
# https://github.com/django/django/blob/main/django/contrib/admin/templates/admin/base_site.html
# base_site.html 입니다!
# urls.py

from django.contrib import admin

urlpatterns = [
    path('admin/', admin.site.urls), # admin.site.urls는 어디를 가리킬까요?
]


###################################
# templates > admin > base_site.html

{% extends "admin/base.html" %}

{% block title %}
{{ title }} | Licat Site
{% endblock %}


{% block branding %}
<h1 id="site-name"><a href="{% url 'admin:index' %}">Licat Site Test</a></h1>
{% endblock %}


{% block messages %}
{% if messages %}
    <ul class="messagelist">{% for message in messages %}
        <li{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</li>
    {% endfor %}</ul>
{% endif %}
{% endblock messages %}


{% block nav-global %}
{% endblock %}


{% block sidebar %}
<div class="module">
    <h2>My Sidebar</h2>
    <ul>
        <li><a href="#">Licat Link 1</a></li>
        <li><a href="#">Licat Link 2</a></li>
        <li><a href="#">Licat Link 3</a></li>
    </ul>
</div>
{% endblock %}


{% block footer %}
<div id="footer">Licat Hello World Test!!</div>
{% endblock %}

###################################
# https://github.com/django/django/blob/4a5048b036fd9e965515e31fdd70b0af72655cba/django/contrib/admin/sites.py#L45
# 위 링크에 AdminSite에 index_title을 오버라이딩한 것입니다.
# blog > admin.py
# from django.contrib import admin
# from .models import Post

# admin.site.register(Post)

from django.contrib import admin
from django.contrib.admin import AdminSite
from django.utils.translation import gettext_lazy as _
from .models import Post


class MyAdminSite(AdminSite):
    # site_title = _('My Site APP Custom Admin')
    # site_header = _('My Site Administration')
    index_title = _('Dashboard Licat Test!!')


class PostAdmin(admin.ModelAdmin):
    list_display = ['id', 'title', 'content_size', 'created_at', 'updated_at']

    def content_size(self, post):
        return '{}글자'.format(len(post.content))
    content_size.short_description = '글자수'


myadminsite = MyAdminSite(name='myadmin')
myadminsite.register(Post, PostAdmin)

###################################
# urls.py

from django.contrib import admin

urlpatterns = [
    path('admin/', admin.site.urls), # admin.site.urls는 어디를 가리킬까요?
]


###################################
# urls.py

from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings
from blog.admin import myadminsite

urlpatterns = [
    path('admin/', myadminsite.urls),
    path('blog/', include('blog.urls')),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

###################################
# 원상복구
# blog > admin.py

from django.contrib import admin
from .models import Post

admin.site.register(Post)

###################################
# 원상복구
# admin.py

from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls')),
]

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

###################################

(지금까지 해온 방식)
모놀리식(템플릿 문법 써서 사용자에게 html,css,js코드를 주는 방법) - API 명세표가 따로 필요 없습니다. 렌더링은 Server에서 다 해서 주니까요.
 - 장점 : 규모가 있지 않은 서비스의 경우 빠른 개발 가능, 소규모 팀인 경우 선택하기 좋습니다.
 - 단점 : 규모가 커질 경우 BE, FE에 역할이 혼재됩니다.


(이번 수업부터 진행할 방식)
 마이크로식(django서버, fe서버가 별도로 운영)
 - 장점 : 서버엔지니어와 프론트엔드 개발자는 API 명세서로 소통하면 됩니다.
 - 단점 : 소규모 프로젝트에서는 의사소통 비용이 올라갑니다. 예를 들어 API 명세서 만들시간이면 서비스 만듭니다.

###################################

pip install djangorestframework
pip install django-cors-headers

###################################

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # django lib app
    'rest_framework',
    'corsheaders',
    # custom app
    'blog',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware', #최상단 추가
    ## 생략
]

CORS_ORIGIN_ALLOW_ALL=True
CORS_ALLOW_CREDENTIALS=True


###################################
# blog > views.py

from django.shortcuts import render
from .models import Post
from django.http import JsonResponse

# def postlist(request):
#     posts = Post.objects.all()
#     return render(request, 'blog/postlist.html', {'posts':posts})


# def postlist(request):
#     posts = [
#         {'title':'1', 'content':'111'},
#         {'title':'2', 'content':'222'},
#         {'title':'3', 'content':'333'},
#     ]
#     return render(request, 'blog/postlist.html', {'posts':posts})

def postlist(request):
    posts = [
        {'title':'1', 'content':'111'},
        {'title':'2', 'content':'222'},
        {'title':'3', 'content':'333'},
    ]
    return JsonResponse(posts, safe=False) # dictionary이외를 받을 경우, safe=False로 설정
###################################
# Django 서버와 완전히 다른 컴퓨터 또는 다른 서버 또는 다른 폴더에서 작동되어야 합니다!
# 별개입니다!
# 이게 마이크로식입니다!
# Django서버는 AWS lightsail, FE서버는 GitHub pages (불가능한 것은 아니지만 매우 어렵습니다.)
# AWS lightsail 안에서 2개의 서버를 돌리시는 것을 권합니다.

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <div id="data"></div>
    <script>
        // fetch로 http://127.0.0.1:8000/blog/ 데이터 가져와서 출력
        fetch('http://127.0.0.1:8000/blog/')
        .then(response => response.json())
        .then(data => {
            console.log(data);
            document.getElementById('data').innerHTML = data;
        });
    </script>
</body>
</html>
###################################
# views.py
# 호기심에 의한 테스트입니다. 실무에서는 이렇게 하지 않습니다!

from django.shortcuts import render
from .models import Post
from django.http import JsonResponse

# def postlist(request):
#     posts = Post.objects.all()
#     return render(request, 'blog/postlist.html', {'posts':posts})


# def postlist(request):
#     posts = [
#         {'title':'1', 'content':'111'},
#         {'title':'2', 'content':'222'},
#         {'title':'3', 'content':'333'},
#     ]
#     return render(request, 'blog/postlist.html', {'posts':posts})

# def postlist(request):
#     posts = [
#         {'title':'1', 'content':'111'},
#         {'title':'2', 'content':'222'},
#         {'title':'3', 'content':'333'},
#     ]
#     return JsonResponse(posts, safe=False) # dictionary이외를 받을 경우, safe=False로 설정

# 호기심에 의한 테스트
# def postlist(request):
#     posts = list(Post.objects.all()) # post는 serializable하지 않습니다.
#     return JsonResponse(posts, safe=False) # dictionary이외를 받을 경우, safe=False로 설정

def postlist(request):
    posts = []
    for i in Post.objects.all():
        posts.append({'title':i.title, 'content':i.content})
    return JsonResponse(posts, safe=False) # dictionary이외를 받을 경우, safe=False로 설정

###################################
# DRF 테스트
# blog > views.py

from django.shortcuts import render
from .models import Post
from django.http import JsonResponse
# rest_framework 추가 후 추가된 코드
from rest_framework import viewsets, permissions, generics, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.decorators import api_view


# FBV 사용하는 방식
@api_view(['GET']) # ['GET', 'POST']하면 둘 다 처리 가능
def postlist(request):
    posts = [
        {'title':'1', 'content':'111'},
        {'title':'2', 'content':'222'},
        {'title':'3', 'content':'333'},
    ]
    serializer = posts # 직렬화 하는 단계
    return Response(serializer) # Response로 반환 되었을 때 데이터를 읽을 수도 있고, POST를 보낼 수도 있습니다.

# CBV 사용하는 방식
# class LicatView(APIView):
#     def get(self, request):
#         posts = [
#             {'title':'1', 'content':'111'},
#             {'title':'2', 'content':'222'},
#             {'title':'3', 'content':'333'},
#         ]
#         serializer = posts # 직렬화 하는 단계
#         return Response(serializer) # Response로 반환 되었을 때 데이터를 읽을 수도 있고, POST를 보낼 수도 있습니다.

# postlist = LicatView.as_view()

###################################
FE > sample.html
# test하고 넘어갑니다.
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <div id="data"></div>
    <script>
        // fetch로 http://127.0.0.1:8000/blog/ 데이터 가져와서 출력
        fetch('http://127.0.0.1:8000/blog/')
        .then(response => response.json())
        .then(data => {
            console.log(data);
            document.getElementById('data').innerHTML = data;
        });
    </script>
</body>
</html>


###################################
# blog > serializers.py
from rest_framework import serializers
from .models import Post
# 좋은 글: https://velog.io/@jewon119/TIL00.-DRF-ModelViewSet-%EA%B0%84%EB%8B%A8-%EC%82%AC%EC%9A%A9%EA%B8%B0

class PostSerializer(serializers.ModelSerializer):
    class Meta:
        model = Post
        fields = '__all__'

###################################
# blog > views.py

from django.shortcuts import render
from .models import Post
from django.http import JsonResponse
# rest_framework 추가 후 추가된 코드
from rest_framework import viewsets, permissions, generics, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.decorators import api_view
from .serializers import PostSerializer


@api_view(['GET', 'POST'])
def postlist(request):
    if request.method == 'GET':
        postlist = Post.objects.all()
        serializer = PostSerializer(postlist, many=True) # 다수의 Queryset을 넘길 때는 many=True
        return Response(serializer.data)
    elif request.method == 'POST':
        serializer = PostSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

###################################
# http://127.0.0.1:8000/blog/ 에서 post 날려보기
{
        "title": "4",
        "content": "44"
}


# id는 적어도 무시합니다.
{
        "id": "10",
        "title": "5",
        "content": "55"
}

###################################
# FE > form.html

<form action="http://127.0.0.1:8000/blog/" method="post">
    <input type="text" name="title" placeholder="제목">
    <input type="text" name="content" placeholder="내용">
    <input type="submit" value="제출">
</form>


###################################

<form action="http://127.0.0.1:8000/blog/" method="post">
    <input type="text" id="title" name="title" placeholder="제목">
    <input type="text" id="content" name="content" placeholder="내용">
    <input type="submit" id="submit_form" value="제출">
</form>
<script>
    function getCookie(name) {
        let value = "; " + document.cookie;
        let parts = value.split("; " + name + "=");
        if (parts.length == 2) return parts.pop().split(";").shift();
    }
    
    let csrfToken = getCookie('csrftoken');

    // submit_form을 눌렀을 때 이벤트가 정지되게 하고 fetch로 데이터가 전송되게 함
    document.getElementById('submit_form').addEventListener('click', function(e) {
        e.preventDefault();
        let title = document.getElementById('title').value;
        let content = document.getElementById('content').value;
        fetch("http://127.0.0.1:8000/blog/", {
            method: "POST",
            headers: {
                "X-CSRFToken": csrfToken,
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                title: title,
                content: content
            })
        });
    })
</script>


###################################
# 위 방식에 문제점은 처음에 서버에서 CSRF token이 없다는 것입니다.
# 쿠키 > clear 해보세요. 제대로 작동 안합니다.
# 우리가 서버에 url로 직접 접근 했을 때에만 CSRF toen을 받을 수 있습니다.
# 따라서 하나의 url을 더 생성하여 거기서 반환되게 하겠습니다.
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.postlist, name='postlist'),
    path('csrf/', views.csrf, name='csrf'),
]

###################################
# views.py
from django.shortcuts import render
from .models import Post
from django.http import JsonResponse
# rest_framework 추가 후 추가된 코드
from rest_framework import viewsets, permissions, generics, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.decorators import api_view
from .serializers import PostSerializer
from django.middleware.csrf import get_token


@api_view(['GET', 'POST'])
def postlist(request):
    if request.method == 'GET':
        postlist = Post.objects.all()
        serializer = PostSerializer(postlist, many=True) # 다수의 Queryset을 넘길 때는 many=True
        return Response(serializer.data)
    elif request.method == 'POST':
        serializer = PostSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


def csrf(request):
    token = get_token(request)
    return JsonResponse({"csrftoken": token})


###################################
# FE > form.html

<form action="http://127.0.0.1:8000/blog/" method="post">
    <input type="text" id="title" name="title" placeholder="제목">
    <input type="text" id="content" name="content" placeholder="내용">
    <input type="submit" id="submit_form" value="제출">
</form>
<script>
    // CSRF 토큰을 가져오는 함수
    // CSRF 토큰은 http://127.0.0.1:8000/blog/csrf에 있음
    // fetch로 호출해서 쿠키에 집어넣어야 함
    fetch("http://127.0.0.1:8000/blog/csrf")
    .then(response => response.json())
    .then(data => {
        console.log(data);
        console.log(data.csrftoken);
        document.cookie = `csrftoken=${data.csrftoken}`;
    });

    function getCookie(name) {
        let value = "; " + document.cookie;
        let parts = value.split("; " + name + "=");
        if (parts.length == 2) return parts.pop().split(";").shift();
    }
    
    let csrfToken = getCookie('csrftoken');

    // submit_form을 눌렀을 때 이벤트가 정지되게 하고 위 fetch가 전송되게 함
    document.getElementById('submit_form').addEventListener('click', function(e) {
        e.preventDefault();
        let title = document.getElementById('title').value;
        let content = document.getElementById('content').value;
        fetch("http://127.0.0.1:8000/blog/", {
            method: "POST",
            headers: {
                "X-CSRFToken": csrfToken,
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                title: title,
                content: content
            })
        });
    })
</script>



###################################
# 여러가지 테스트
from django.shortcuts import render
from .models import Post
from django.http import JsonResponse
# rest_framework 추가 후 추가된 코드
from rest_framework import viewsets, permissions, generics, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.decorators import api_view
from .serializers import PostSerializer
from django.middleware.csrf import get_token
from django.http import HttpResponse


@api_view(['GET', 'POST'])
def postlist(request):
    if request.method == 'GET':
        postlist = Post.objects.all()
        serializer = PostSerializer(postlist, many=True) # 다수의 Queryset을 넘길 때는 many=True
        # return Response(100)
        # return Response('hello world')
        # return Response(postlist) # Queryset을 넘길 때 앞에서 직렬화 하는 코드 있어야 함
        # return Response(serializer.data)
        return HttpResponse(serializer.data)
    elif request.method == 'POST':
        serializer = PostSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


def csrf(request):
    token = get_token(request)
    return JsonResponse({"csrftoken": token})


###################################
# about:blank
fetch('http://127.0.0.1:8000/blog/')
        .then(response => response.json())
        .then(data => {
            console.log(data);
        });

###################################